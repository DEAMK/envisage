Using Plugins
=============

Envisage brings together the notions of *extension points* and *services*
using the concept of *plugins*. Plugins simply provide a way to deliver
extension points, contributions to extension points, and services into an
application. In Envisage, plugins are located and managed by the
*plugin manager*. Envisage is designed such that you can implement your own
plugin manager, but by default, it uses an implementation based on
`Python Eggs`_.

As mentioned previously, plugins are just the mechanism for delivering new
functionality to an application, and they can do 3 simple things:-

1) offer extension points
2) make contributions to extension points (including its own)
3) create and publish services

Conceptually, plugins are split into two halves.

The *plugin definition*
-----------------------

The *plugin definition* is responsible for offering extension points and making
contributions to them. In the egg-based implementation this means that this is
handled in the *setup.py* file of the plugin's egg.

The *plugin definition* provides the following information about a plugin:-

- a globally unique identifier (e.g. *acme.motd*)

  technically, this identifier only need be unique within your application, but
  since the intent is for applications to be able to include plugins from
  all over the world, using the common reverse domain nam notation is probably
  a good idea!

- a version

  this allows different applications to use different versions of a plugin.

- a list of the plugins that this plugin requires

  this is used to start the plugins in the appropriate order (i.e. if plugin
  A requires plugin B, then plugin B will be started first).

- the extension points that the plugin offers

- any contributions that the plugin makes to extension points

- a reference to the *plugin implementation* (if any)

Let's take a look at the plugin definition from the *acme.motd* plugin:-

::

    setup(
        name                 = 'acme.motd',
        version              = '0.1a1',
	...
        install_requires     = [
          'enthought.envisage>=3.0a1',
        ],

        entry_points = """

        [enthought.envisage.plugins]
        motd = acme.motd.motd_plugin:MOTDPlugin

        [enthought.envisage.extension_points]
        acme.motd.messages = acme.motd.api:IMessage
    
        """
    )

The *plugin implementation*
---------------------------

A *plugin implementation* is required if you want to create and start any
services, and should be a class that implements the IPlugin_ interface, which
usually means creating a subclass of Plugin_).

Note that if all your plugin does is contribute to existing extension points
then the chances are you don't need to write a plugin implementation.

Lets take a look at the plugin implementation from the *acme.motd* plugin:-

::

    class MOTDPlugin(Plugin):
    """ The 'Message of the Day' plugin """

        # All contributed messages.
        messages = ExtensionPoint(List(IMessage), 'acme.motd.messages')

	...

        def start(self, application):
            """ Start the plugin. """

            # Use the contributed messages to populate a MOTD object.
            motd = MOTD(messages=self.messages)
        
            # This is a bit of overkill here, but this shows how we can register
            # the MOTD object as a service so that other plugins can use it if
            # they so wish.
            motd_service_id = application.register_service(IMOTD, motd)
        
            # And this is how we could look the service up!
            motd_service = application.get_service(IMOTD)

            # Get the message of the day...
            message = motd_service.motd()

            # ... and print it.
            print '\n"%s"\n\n- %s' % (message.text, message.author)
        
            return

        def stop(self, application):
            """ Stop the plugin. """

            # Unregister the MOTD service.
            application.unregister_service(motd_service_id)
        
	    return

Plugin implementations have two important methods, *start* and *stop*! The
*start* method is a good place to create and register services, and *stop* is
a good place to unregister them and cleanup!


.. _IPlugin: ../../enthought/envisage/i_plugin.py
.. _Plugin: ../../enthought/envisage/plugin.py
.. _`Message of the Day`: ../../examples/apps/MOTD
.. _acme.motd: ../../examples/src/acme.motd/setup.py
.. _acme.motd.software_quotes: ../../examples/src/acme.motd.software_quotes/setup.py

.. _`Python Eggs`: http://peak.telecommunity.com/DevCenter/PythonEggs
