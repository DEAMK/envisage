Using Services
==============

Services are a fundemental part of Envisage applications as they are the
objects that do the actual work! However, One of the first problems we have in
such a service-based system is how to find them! This is where the
*service registry* comes in.

The *service registry* provides a "yellow pages" style mechanism in that
services are published and looked up by *interface*, or *type*. It is called
a "yellow pages" mechanism because it is just like looking up a telephone
number in the "Yellow Pages" phone book. You use the "Yellow Pages" instead
of the "White Pages" when you don't know the number of the person you want to
call but you do know what *kind* of service you require. For example, if you
have a leaking pipe, you know you want a plumber, so you pick up your "Yellow
Pages", go to the "Plumbers" section and choose one that seems to fit the bill
based on price, location, certification etc. The *service registry* does
exactly the same thing as the "Yellow Pages", only with objects, and it even
allows you to publish your own for free (unlike the "real" one)!

Services are managed through the following methods on the IApplication_
interface.

::
    def get_service(self, interface, query='', minimimize='', maximize=''):
        """ Return at most one service that matches the specified query.

        """

    def get_service_properties(self, service_id):
        """ Return the dicitonary of properties associated with a service.

        """
        
    def get_services(self, interface, query='', minimimize='', maximize=''):
        """ Return all services that match the specified query.

        """

    def register_service(self, interface, obj, properties=None):
        """ Register a service.

        Returns a service Id that can be used to retrieve any service
        properties, and to unregister the service.

        """

    def unregister_service(self, service_id):
        """ Unregister a service.

        """

The easiest way to explain the workings of these methods is to take a look at
some examples, and to continue our plumber theme, lets assume we have the
following interface and implementation:-

::
    class IPlumber(Interface):
        """ What plumbers do! """

	# The plumber's name.
	name = Str

	# The plumber's location.
	location = Str

	# The price per hour (in say, Estonian Krooni ;^)
	price = Int

	def fix_leaking_pipe(self, pipe):
	    """ Fix a leaking pipe! """

    class Plumber(HasTraits):
        """ An actual plumber implementation! """

	implements(IPlumber)

	# The plumber's name.
	name = Str

	# The plumber's location.
	location = Str

	# The price per hour (in say, Estonian Krooni ;^)
	price = Int

	def fix_leaking_pipe(self, pipe):
	    """ Fix a leaking pipe! """

	    ... code that actually fixes it! ...


1) Registering a service with *register_service*

To register a service, all we have to do is create an object and call the
*register_service* method, passing it the interface/type that we want to
publish the object under (think "Yellow Pages" section), and the object that
we want to publish. Note that the object that we publish does *not* have to
inherit from any particular base class - any arbitrary Python object will do:-

::
	fred = Plumber(name='fred', location='BH1', price=90)
	application.register_service(IPlumber, fred)

We can also associate an arbitrary dictionary of properties with an object when
we register it. These properties (along with the actual attributes of the
service itself) can be used later to lookup the service using the query
mechanism as shown in example 4).

::
	wilma = Plumber(name='wilma', location='BH6')
	application.register_service(IPlumber, wilma, {'price' : 125})

2) Looking up a service with *get_service*

Looking up a service is just as easy, we simply call *get_service* with the
interface/type of service that we require:-

::
	plumber = application.get_service(IPlumber)

If we assume that we have registered both *fred* and *wilma* as in example 1)
then we have know way of knowing which of those would be returned here. It
does *not* necessarily reflect on the order in which they were added, so don't
depend on it!

3) Looking up a list of services with *get_services*

We can also lookup *all* services of a particular interface/type:-

::
	plumbers = application.get_services(IPlumber)

Assuming the registrations in example 1), this would return a list containing
both *fred* and *wilma*, again in arbitrary order.

4) Using queries

The *get_service* and *get_services* methods both take optional arguments
to allow more control over the selection of an appropriate service. The first
of these is the *query* argument which is a string containing an arbitrary
Python expression that is evaluated once per service, with the service only
being returned if the expression evaluates to True. The namespace that the
expression is evaluated in is created by first adding each of the service's
attributes, followed by any additional properties that we specified when the
service was registered (i.e. properties take precedence over attributes).

Once again, assuming that we have registered *fred* and *wilma* as in example
1), lets look at how we can use the query mechanism to be more selective
about which plumbers we lookup.

Find all plumbers whose price is less than 100 Krooni/Hour:-

::
	plumbers = application.get_services(IPlumber, "price < 100")

Which would return a list containing one plumber, *fred*.

Find plumbers named *fred*:-

::
	plumbers = application.get_services(IPlumber, "name == 'fred'")

Which, again (and unsurprisingly) would return a list containing just *fred*.

Queries can be used with the singular form of the method (*get_service*) too,
in which case only one of the services that matches the query is returned:-

::
	plumber = application.get_services(IPlumber, "price < 200")

Which would return *either*, *fred* or *wilma*.	

5) Using *minimize* or *maximize*

The minimize and maximize arguments to the *get_service* and *get_services*
methods allow the services returned to be sorted by an attribute or property
in either ascending or descending order respectively.

To find the cheapest plumber:-

::
	cheapest = application.get_service(IPlumber, minimize='price')

Or, if you believe that you get what you pay for, the most expensive:-

	cheapest = application.get_service(IPlumber, maximize='price')

Minimize and maximize can also be used in conjunction with a query. For example
to find the cheapest plumber in my area:-

::
	cheap_and_local = application.get_service(
            IPlumber, location='BH6', maximize='price'
	)

Which would finally give some work to *wilma*!

6) Unregistering a service with *unregister_service*

When we register a service, Envisage gives us back a value that uniquely
identifies the service within the current process (i.e. it is not suitable for
persisting to use next time the application is run). To unregister a service
all we have to do is call the *unregister_service* method, passing in the
appropriate Id:-

::
	fred = Plumber(name='fred', location='BH1', price=90)
	fred_id = application.register_service(IPlumber, fred)

	...

	application.unregister_service(fred_id)

7) Getting the properties associated with a service

If we associated an arbitrary dictionary of properties with an object when
we registered it. We can retreive those properties by calling the
*get_service_properties* method with the appropriate service Id:-

::
	wilma = Plumber(name='wilma', location='BH6')
	wilma_id = application.register_service(IPlumber, wilma, {'price' : 125})
	...

	properties = application.get_service_properties(wilma_id)

Which would return a dictionary containing the following:-

::
	{'price' : 125}

Note that the dictionary that is returned is the actual properties dictionary
used by the service registry to evaluate queries against, so if you are
dynamically keeping track of an object via some property (an example might
be CPU usage etc) then all you have to do is update the dictionary. However,
in practise, it is more common to use the actual attributes of a service for
this purpose.
