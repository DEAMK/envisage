Syntactic Sugar is Sweet
========================

While everything that the framework offers is available via the IApplication
interface, Envisage also provides some 'syntactic sugar' (in the form of trait
types and metadata) to make the definition and access of extension points and
service more declarative.

Extension Points
----------------

To access the contributions to an extension point (and to declare the
existence of the extension point), a plugin can use the 'ExtensionPoint'
trait type::

  class MyPlugin(Plugin):
      id    = 'my.plugin'
      names = ExtensionPoint(List(Str), id='names', desc='Naming of names')

From then on to access the contributions the plugin simply gets the value of
the trait as usual via::

     self.names

To contribute to an extension point a plugin can use the 'extension_point'
trait metadata::

   class AnotherPlugin(Plugin):
       id    = 'another.plugin'
       names = List(['Fred', 'Wilma'], extension_point='names')

Services
--------

To *access* a service, a plugin can use the 'Service' trait type::

    class Foo(HasTraits):
       pass

    class ServiceUser(Plugin):
        id  = 'service.user'
	foo = Service('Foo')

and then every time *self.foo* is accessed, the service is looked up via
the application.

To contribute a service, a plugin can use the 'service' trait metadata::

    class ServiceProvider(Plugin):
        id  = 'service.provider'
	foo = Instance('Foo', service=True)

Where the 'foo' trait can be initialized in any of the usual ways, but it
is recommended to use a default initializer so that the service is not created
until somebody asks for it.

Note that we also reference the protocol by name in the trait definitions,
again to make sure we only load modules when actually required.

