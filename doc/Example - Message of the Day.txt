The "Message of the Day" (MOTD) Example
=======================================

Only marginally more complicated than the traditional "Hello World" example,
this application simply prints a random "message of the day". Obviously, if we
actually had to write this application, we might not choose to use a framework
like Envisage (it is one of the rare applications that are so simple that why
would you bother), but it does serve to illustrate all of the fundemental
aspects of building Envisage applications.

Before we dive right in to building our extensible application, let's take a
small, but important, step back. Envisage is designed to be an integration
platform - a place where you can bring along your existing code and with a
(hopefully) minimal amount of effort, make it work with the rest of the
application. Because of this, we will start the MOTD example by designing the
application without any knowledge of Envisage whatsoever. This is obviously a
good idea in general, as it allows our code to be reused outside of Envisage
applications.

All of the code for this example can be found in the 'examples' directory of
the Envisage distribution.

Plain Ol' MOTD
--------------

So lets take a look at our non-Envisage MOTD application. A good place to
start as a developer *using* a package is to look at any interfaces exposed
in the 'api.py' module.

In this case, there are just 2 interfaces, the main interface for the MOTD
application, IMOTD_, and the interface that must be implemented by the messages
returned by the *motd* method, IMessage_.

The default implementation of the IMOTD_ interface is found in the MOTD_
class. As you can see, the MOTD_ class simply contains a list of messages and
when its 'motd' method is called, it simply returns a random choice from the
list.

An example of using our MOTD_ class at the Python prompt might be:-

>>> from acme.motd.api import Message, MOTD
>>> motd = MOTD(messages=[Message(author='Anon', text='Hello World!')])
>>> message = motd.motd()
>>> print '"%s" - %s' % (message.text, message.author)
"Hello World!" - Anon
>>> 

Well, we had to get "Hello World" in there somewhere!

The important point here is that this code is written without any knowledge of
Envisage, or extensible applications. It is just a small, reusable piece of
code.

An Extensible MOTD
------------------

Now, this example has one obvious place where we might like extension to
occur, and that is the list of messages that the MOTD chooses from.

In Envisage, we can create an extensible version of the MOTD_ class, as
follows (for the full code see, the ExtensibleMOTD_ class):-

::
  class ExtensibleMOTD(MOTD):
      """ An extensible MOTD class. """

      messages = ExtensionPoint(List(IMessage), id='acme.motd.messages')

As you can see, we simply inherit from our default implementation, and
declare that the *messages* trait is an extension point that is identified
by the string "acme.motd.messages" (extension point identifiers should use the
familiar reverse domain name syntax as they are intended to be *globally*
unique). Now, when the *messages* trait is accessed, Envisage will go to the
extension registry and find all of the contributions to the extension point.

The MOTD plugin
---------------

As we know, the way that we deliver new functionality into an Envisage
application is via plugins. In this case, although it is a bit of overkill,
we are going to use a plugin to offer an instance of the ExtensibleMOTD_ class
as a service. The plugin will then immediately look up the service, and call
its *motd* method to get the message of the day.

The plugin code is found in the MOTDPlugin_ class.

Contributing some new messages
------------------------------

Now we need to contribute some messages to the "acme.motd.messages" extension
point. In this case, we have trawled the internet to find pithy quotes about
software development, and we have created a bunch of messages and put them
in the module acme.motd.software_quotes.messages_.

Bringing it all together
------------------------

As you may have noticed, we have so far avoided the issues of how the MOTD
plugin gets created and started, how the contributed messages actually
get into the application, and how the application actually gets started. We
have avoided these issues for a good reason. Envisage is designed to allow
the application writer to control all of these aspects themselves while
maintaining the reusability of the actual application code. By default, 
Envisage uses an extension registry and a plugin manager based on Python Eggs
but as you have seen, nothing in the MOTD example up to this point mentions
Eggs at all.

So, assuming you are happy to use Python Eggs to deploy your applications,
lets take a look at what we need to do to create the MOTD application.

The example is split into two eggs - the "acme.motd" egg and the
"acme.motd.software_quotes" egg.



 You almost think of an egg as being
 synonymous with plugin, although of course can think of an egg being a plugin

As previously mentioned, Envisage is designed such that you can implement your
own schemes for the extension registry, the service registry and the plugin
manager, but by default we use a scheme based on Python Eggs.

Using this scheme, we put all of the eggs used in an application into a
directory (or in fact, list of directories), and then we have a small piece
of bootstrap code tHence, the 





contributing to and looking up extension points, and for






+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



First lets have a look at the interfaces
So our non-extensible, non-Envisage MOTD class might be MOTD_


As an side, the list is actually a list of objects that implement the IMessage_
interface. Using interfaces may seem to be a little bit of overkill here, but
it illustrates how it might look in a 'real' application. A default
implementation of the IMessage_ interface is provided by the Message_
class.

An example of using our MOTD_ class at the Python prompt might be:-

>>> from acme.motd.api import Message, MOTD
>>> motd = MOTD(messages=[Message(author='Anon', text='Hello World!')])
>>> message = motd.motd()
>>> print '"%s" - %s' % (message.text, message.author)
"Hello World!" - Anon
>>> 

Well, we had to get "Hello World" in there somewhere!

Now, to create an actual application we might just use code similar to that
above with a hard-coded list of all of the possible messages, or we might
even put the messages in a file and read them from there, or any number of
other ways of allowing other developers to contribute new messages. Since we
are using Envisage, we will use an Extension Point.

We will leave our original MOTD_ class as is, and provide a new subclass,
ExtensibleMOTD_ that contains an extension point at the list of messages.

As you can see, all we have done is change the definition of the 'messages'
trait from:-

::
  messages = List(IMessage)

to

::
  messages = ExtensionPoint(List(IMessage), id='acme.motd.messages')

This tells Envisage that when the 'messages' trait is accessed to go and
get all contributions to the 'acme.motd.messages' extension point (extension
point identifiers should use the familiar reverse domain name syntax as they
are intended to be *globally* unique).

So lets try out our new extensible class:-

>>> from acme.motd.api import ExtensibleMOTD
>>> motd = ExtensibleMOTD()
>>> message = motd.motd()
>>> print '"%s" - %s' % (message.text, message.author)
"Work hard and be good to your Mother" - Anon
>>> 

Looking at the code we can see that the "Work hard..." message is the one that
gets returned if the list of messages is empty, which in this case is correct
since we haven't yet made any contributions to the 'acme.motd.messages'
extension point.

To see how we do that, let's first introduce 


Note that this says nothing about how the application actually gets hold
of the contributions to this extension point (i.e. the actual messages), and in
fact this is up to the application writer. Envisage however provides 
The next question is, "So how to I make a contribution to the extension point?"




.. _`IMOTD`: https://svn.enthought.com/enthought/browser/trunk/enthought.envisage_3.0/examples/src/acme.motd/acme/motd/i_motd.py

.. _`MOTD`: https://svn.enthought.com/enthought/browser/trunk/enthought.envisage_3.0/examples/src/acme.motd/acme/motd/motd.py

.. _`ExtensibleMOTD`: https://svn.enthought.com/enthought/browser/trunk/enthought.envisage_3.0/examples/src/acme.motd/acme/motd/extensible_motd.py

.. _`IMessage`: https://svn.enthought.com/enthought/browser/trunk/enthought.envisage_3.0/examples/src/acme.motd/acme/motd/i_message.py

.. _`Message`: https://svn.enthought.com/enthought/browser/trunk/enthought.envisage_3.0/examples/src/acme.motd/acme/motd/message.py
